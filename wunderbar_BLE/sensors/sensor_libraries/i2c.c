
/** @file   i2c.c
 *  @brief  This driver contains definitions of functions for working with TWI-I2C Nordic module
 *          and corresponding macros, constants,and global variables.
 *
 *  @author MikroElektronika
 *  @bug    No known bugs.
 */
 
/* -- Includes -- */

#include "i2c.h"
#include "ppi.h"
#include "nrf_delay.h"
#include "gpio.h"

#define TWI_PPI_CHANNEL 0

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**@brief Private function declarations*/

/**@brief Configure GPIO of pins for TWI (pseudo open drain). */
static void i2c_pin_configure(TWI_STRUCT* i2c);

/**@brief Make sure the bus is idle. If needed, clear it manually. */
static bool i2c_clear_bus(TWI_STRUCT* i2c);

/**@brief Reset procedure for potentially locked-up TWI unit (PAN56). */
static void i2c_reset_bus_lockup(TWI_STRUCT* i2c, uint8_t scl, uint8_t sda, TWI_FREQUENCY freq);

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ---------------------------------------
// --- Private function implementations ---
// ---------------------------------------
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/** @brief  This function configure GPIO of pins for TWI (pseudo open drain).
 *
 *  @param  i2c  Pointer to an record that relates to the Two-Wire module.
 *
 *  @return  Void.
 */

static void i2c_pin_configure(TWI_STRUCT* i2c) 
{
		// off mode and disabled.
		// scl = OUT, CONNECT, PULLUP, S0D1, SENSE_DIS
		// 17 16 | 10 9 8 | 7 ... 4 | 3 2 | 1 | 0
		// 0  0  |  1 1 0 | 0 0 0 0 | 1 1 | 0 | 1
		GPIO0->PIN_CNF[i2c->PSELSCL] = 0x000000000000060d;
		GPIO0->PIN_CNF[i2c->PSELSDA] = 0x000000000000060d;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/** @brief  Make sure the bus is idle. If needed, clear it manually.
 *
 *  @param  i2c  Pointer to an record that relates to the Two-Wire module.
 *
 *  @return  false in case that error is occurred, otherwise true.
 */

static bool i2c_clear_bus(TWI_STRUCT* i2c) 
{
		bool ok;

		uint32_t scl_cfg = GPIO0->PIN_CNF[i2c->PSELSCL];
		uint32_t sda_cfg = GPIO0->PIN_CNF[i2c->PSELSDA];

		i2c->ENABLE = TWI_DISABLED;

		gpio_write(i2c->PSELSCL, true);
		gpio_write(i2c->PSELSDA, true);
		nrf_delay_us(4);

		GPIO0->PIN_CNF[i2c->PSELSCL] = 0x000000000000060d;
		GPIO0->PIN_CNF[i2c->PSELSDA] = 0x000000000000060d;

		if (gpio_read(i2c->PSELSCL) && gpio_read(i2c->PSELSDA)) 
		{
				ok = true;
				goto RETURN_STATE;
		}

		GPIO0->PIN_CNF[i2c->PSELSCL] = 0x000000000000060d;

		ok = false;
		for (uint8_t i = 18; i--;) 
		{
				gpio_write(i2c->PSELSCL, false);
				nrf_delay_us(4);
				gpio_write(i2c->PSELSCL, true);
				if (gpio_read(i2c->PSELSDA)) 
				{
						ok = true;
						break;
				}
				nrf_delay_us(4);
		}

		RETURN_STATE:
		// restore state of gpio and twi.
		i2c->ENABLE = TWI_ENABLED; 
		GPIO0->PIN_CNF[i2c->PSELSCL] = scl_cfg;
		GPIO0->PIN_CNF[i2c->PSELSDA] = sda_cfg;
		return ok;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/** @brief  Reset procedure for potentially locked-up TWI unit (PAN56).
 *
 *  @param  i2c  Pointer to an record that relates to the Two-Wire module.
 *  @param  scl  I2C interface SCL pin.
 *  @param  sda  I2C interface SDA pin.
 *  @param  freq Requested serial clock rate 
 *
 *  @return Void.
 */

static void i2c_reset_bus_lockup(TWI_STRUCT* i2c, uint8_t scl, uint8_t sda, TWI_FREQUENCY freq) 
{
		i2c->EVENTS_ERROR = 0;
		i2c->ENABLE = TWI_DISABLED;
		i2c->POWER  = 0;
		nrf_delay_us(5);
		i2c->POWER  = 1;
		i2c->ENABLE = TWI_ENABLED;
		i2c_init(i2c, scl, sda, freq);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ---------------------------------------
// --- Public function implementations ---
// ---------------------------------------
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/** @brief  Initialize TWI peripheral for given setting.
 *
 *  @param  i2c  Pointer to an record that relates to the Two-Wire module.
 *  @param  scl  I2C interface SCL pin.
 *  @param  sda  I2C interface SDA pin.
 *  @param  freq Bus frequency
 *
 *  @return false in case that error is occurred, otherwise true.
 */

bool i2c_init(TWI_STRUCT* i2c, uint8_t scl, uint8_t sda, TWI_FREQUENCY freq) 
{

		i2c->EVENTS_RXDREADY = 0;
		i2c->EVENTS_TXDSENT  = 0;

		i2c->PSELSCL   = scl;
		i2c->PSELSDA   = sda;
		i2c_pin_configure(i2c);

		i2c->FREQUENCY = freq;

		i2c->ENABLE = TWI_ENABLED;

		return i2c_clear_bus(i2c);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/** @brief  Sends data byte via the I2C bus.
 *
 *  @param  i2c  Pointer to an record that relates to the Two-Wire module.
 *  @param  addr Slave address.
 *  @param  len  Number of bytes to be sent.
 *  @param  buf  Data to be sent.
 *  @param  stop Trigger STOP task flag.
 *
 *  @return Number of transferred bytes or negative error code.
 */

int i2c_write(TWI_STRUCT* i2c, uint8_t addr, uint16_t len, uint8_t* buf, bool stop) 
{
		// Remember settings in case the peripheral locks up.
		uint8_t scl_pin = i2c->PSELSCL;
		uint8_t sda_pin = i2c->PSELSDA;
		uint32_t freq = i2c->FREQUENCY;

		uint32_t timeout = 20000;
		uint16_t num_sent = 0;
		int retval = 0;

		if (len == 0) 
	  {
				return 0;
		}

		i2c->SHORTS = 0;                                       /**< Disable short-cuts. */
		i2c->ADDRESS = addr;                                   /**< Set slave address. */
		i2c->TASKS_STARTTX = 1;                                /**< Start 2-Wire master transmit sequence. */
		nrf_delay_us(20);
		
		while (true) 
		{
				i2c->TXD = *buf++;

				while (i2c->EVENTS_TXDSENT == 0 && (i2c->EVENTS_ERROR == 0) && (--timeout)) 
				{
						;
				}
				
				// Check if timeout or error event occurred.
				if ( timeout == 0 ||  i2c->EVENTS_ERROR != 0  )
				{ 
					  // Reset bus and return with error code.
						i2c_reset_bus_lockup(i2c, scl_pin, sda_pin, (TWI_FREQUENCY)freq);
						retval = timeout == 0 ? TWI_ERROR_WRITE_TIMEOUT : TWI_ERROR_WRITE_NACK;
						goto BAIL;
				}
				
				num_sent += i2c->EVENTS_TXDSENT;
				i2c->EVENTS_TXDSENT = 0;
				
				if (--len == 0) 
				{
				    break;
				}
		}
    
		// Check if it should be triggered STOP task.
		if (stop) 
		{
				i2c->EVENTS_STOPPED = 0;
				i2c->TASKS_STOP     = 1;
				while (i2c->EVENTS_STOPPED == 0) 
				{ 
						;
				}	
		}

		BAIL:
		
		return retval == 0 ? num_sent : retval;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/** @brief  Reads a byte from the I²C bus.
 *
 *  @param  i2c  Pointer to an record that relates to the Two-Wire module.
 *  @param  addr Slave address.
 *  @param  len  Number of bytes to be received.
 *  @param  buf  Pointer to the receive buffer.
 *
 *  @return Number of received bytes or negative error code.
 */

int i2c_read (TWI_STRUCT* i2c, uint8_t addr, uint16_t len, uint8_t* buf) 
{
		// Remember settings in case the peripheral locks up.
		uint8_t scl_pin = i2c->PSELSCL;
		uint8_t sda_pin = i2c->PSELSDA;
		uint32_t freq = i2c->FREQUENCY;

		uint32_t timeout = 20000;
		uint16_t num_recv = 0;
		int retval = 0;


		if (len == 0) 
		{
		    return 0;
		}
		i2c->ADDRESS   = addr;

    // Config short-cuts.
		if (len == 1) 
		{
		    i2c->SHORTS = 2;                                                       /**< Short-cut with STOP task. */
		} else 
	  {
		    i2c->SHORTS = 1;                                                       /**< Short-cut with SUSPEND task. */
		}
    
		
		i2c->EVENTS_RXDREADY = 0;                                                  /**< Clear byte received event. */
		i2c->TASKS_STARTRX  = 1;                                                   /**< Start 2-Wire master transmit sequence. */

		while (true) 
		{
				while (i2c->EVENTS_RXDREADY == 0 && (i2c->EVENTS_ERROR == 0) && (--timeout)) 
				{
						;
				}
 
				// Check if timeout or error event occurred. 
				if ( timeout == 0 || i2c->EVENTS_ERROR != 0 )
				{ 
					  // Reset bus and return with error code.
						i2c_reset_bus_lockup(i2c, scl_pin, sda_pin, (TWI_FREQUENCY)freq);
						retval = timeout == 0 ? TWI_ERROR_READ_TIMEOUT : TWI_ERROR_READ_NACK;
						goto BAIL;
				}

				buf[num_recv++] = i2c->RXD;

				i2c->EVENTS_RXDREADY = 0;
				
				if (--len == 0) 
				{
						break;
				}
				
        // Reconfig short-cuts.				
				if (len == 1) 
				{
						i2c->SHORTS = 2;  
				} else 
				{
						i2c->SHORTS = 1;  
				}   

			i2c->TASKS_RESUME = 1;                                                   /**< Resume transaction. */
		}

		while (i2c->EVENTS_STOPPED == 0) 
    { 
				;
		}
		i2c->EVENTS_STOPPED = 0;

		BAIL:

		nrf_delay_us(20);
		return retval == 0 ? num_recv : retval;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/** @brief  This function do write then read bytes from bus.
 *
 *  @param  i2c  Pointer to an record that relates to the Two-Wire module.
 *  @param  addr Slave address.
 *  @param  len_w  Number of bytes to be sent.
 *  @param  buf_w  Pointer to the sent data.
 *  @param  len_r  Number of bytes to be received.
 *  @param  buf_w  Pointer to the receive buffer. 
 *
 *  @return Summation of number of received and number of sent bytes, or negative error code.
 */

int i2c_write_read(TWI_STRUCT* i2c, uint8_t addr, uint16_t len_w, uint8_t* buf_w, uint16_t len_r, uint8_t* buf_r) 
{
	  // Write data.
		int result_w = i2c_write(i2c, addr, len_w, buf_w, true);
		if (result_w != len_w) 
		{
				return result_w;
		}

		// Read data.
		int result_r = i2c_read(i2c, addr, len_r, buf_r);
		if (result_r < 0) 
		{
				return result_r;
		}

		return result_w + result_r;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/** @brief  Enable I2C module.
 *
 *  @param  i2c  Pointer to an record that relates to the Two-Wire module.
 *
 *  @return Void.
 */

void i2c_enable(TWI_STRUCT* i2c)
{
    i2c->ENABLE = TWI_ENABLED;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/** @brief  Disable I2C module.
 *
 *  @param  i2c  Pointer to an record that relates to the Two-Wire module.
 *
 *  @return Void.
 */

void i2c_disable(TWI_STRUCT* i2c)
{
    i2c->ENABLE = TWI_DISABLED;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
