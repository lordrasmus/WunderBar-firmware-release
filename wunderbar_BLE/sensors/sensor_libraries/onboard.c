
/** @file   onboard.c
 *  @brief  Contains definitions of functions for onboarding mode of sensor, corresponding macros, and global variables.
 *
 *  @author MikroElektronika
 *  @bug    No known bugs.
 */
 
/* -- Includes -- */

#include "onboard.h"
#include "nrf_soc.h"
#include "ble_driver.h"
#include "app_timer.h"
#include "gpiote.h"
#include "nrf_gpio.h"

#define BUTTON_BOOTLOAD_TIMEOUT_MS  2000                                       /**< Button pressed timeout for entering into bootload mode. */

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**@brief  Private global variables. */

static onboard_mode_t  onboard_mode;                                           /**< Indicates whether onboard mode is active or not. */
static onboard_mode_t  onboard_mode_ps_storage __attribute__((aligned(4)));    /**< Onboard mode load/stored from/to persistent memory. */
static onboard_state_t onboard_state;                                          /**< Contains current state of onboarding. */
static app_timer_id_t  onboard_timer_id;                                       /**< Onboard timer ID. */
static uint8_t         DEFAULT_ONBOARD_MODE = ONBOARD_MODE_ACTIVE;             /**< Default onboard mode is active. */

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**@brief  Declarations of static functions. */

static void onboard_on_timeout(void* context);
static void onboard_input_on_down(void);
static void onboard_input_on_up(void);
static void onboard_change_mode(void);
static void onboard_reset(void);

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/** @brief  This function reads onboard mode from pstorage and init timer and input interrupt callbacks
 *
 *  @return false in case error occurred, otherwise true.
 */

bool onboard_init(void)
{
    uint32_t err_code;
  
    // Read onboard mode from p_storage.
    if(!init_global((uint8_t*)&onboard_mode_ps_storage, (uint8_t*)&DEFAULT_ONBOARD_MODE, sizeof(onboard_state))) 
    {
        return false;
    }
    
    onboard_mode = onboard_mode_ps_storage;
    
    // Create onboard timer. 
    err_code = app_timer_create(&onboard_timer_id, APP_TIMER_MODE_REPEATED, onboard_on_timeout);
    if(err_code != NRF_SUCCESS)
    {
        return false;
    }
    
    // Create onboard button interrupt.
    ble_set_input_callback(BUTTON_PIN, NRF_GPIO_PIN_SENSE_LOW, NRF_GPIO_PIN_PULLUP, onboard_input_on_down);
    ble_enable_input_interrupt();
    
    return true;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/** @brief       This function return current onboard mode.
 *
 *  @retval      Current onboard mode.
 */

onboard_mode_t onboard_get_mode(void)
{
    return onboard_mode;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/** @brief       This function return current onboard state.
 *
 *  @retval      Current onboard state.
 */

onboard_state_t onboard_get_state(void)
{
    return onboard_state;
}
  
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**@brief       This function is called when there is a successful entry to pstorage.
 *
 * @retval      Void.
 */

void onboard_on_store_complete(void)
{
	  // Check if it is necessary to write mode to persistent memory.
    if(onboard_state == ONBOARD_STATE_WAIT_TO_STORE_MODE)
    {
        pstorage_driver_request_store((uint8_t*)(&onboard_mode));
    }
		// Storing complete, reset device.
    else if(onboard_state == ONBOARD_STATE_STORE_MODE)
    {
        onboard_reset();
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**@brief       This function handle disconnection event in onboarding active mode.
 *
 * @retval      Void.
 */

void onboard_on_disconnect(void)
{
    // Check if it is disconnect event on our disconnect request from "onboard_input_on_down()"
    if(onboard_state == ONBOARD_STATE_RUN)
    {
        ble_disable_input_interrupt();
        onboard_change_mode();
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**@brief       On button press callback.
 *
 * @retval      Void.
 */

static void onboard_input_on_down(void)
{
    // Start onboard timer and input interrupts.
    ble_set_input_callback(BUTTON_PIN, NRF_GPIO_PIN_SENSE_HIGH, NRF_GPIO_PIN_PULLUP, onboard_input_on_up);
  
    app_timer_start(onboard_timer_id, APP_TIMER_TICKS(BUTTON_BOOTLOAD_TIMEOUT_MS, 0), NULL);
    
    // If there is valid connection, close it.
    ble_disconnect();
  
    // Button down detect. 
    onboard_state = ONBOARD_STATE_BUTTON_DOWN;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**@brief       On button release callback.
 *
 * @retval      Void.
 */

static void onboard_input_on_up(void)
{
    // Button up detect. Disable onboard timer and input interrupts.
    app_timer_stop(onboard_timer_id);
    ble_disable_input_interrupt();
    
    // Toggle mode.
    onboard_change_mode();
}

  
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**@brief       On timer expire callback.
 *
 * @retval      Void.
 */

static void onboard_on_timeout(void* context) 
{
    // Reset module and go to bootload mode.
    onboard_reset();
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**@brief       This function toggle onboard mode ( ACTIVE <-> IDLE ).
 *
 * @retval      Void.
 */

static void onboard_change_mode(void)
{
    if(onboard_mode == ONBOARD_MODE_IDLE)
    {
        onboard_mode_ps_storage = ONBOARD_MODE_ACTIVE;
    }
    else
    {
        onboard_mode_ps_storage = ONBOARD_MODE_IDLE;
    }
    
    // Request to store new mode.
    if(pstorage_driver_request_store((uint8_t*)(&onboard_mode_ps_storage)))
    {
        // Start storing.
        onboard_state = ONBOARD_STATE_STORE_MODE;
    }
    else
    {
        // Wait to finish pstorage-write in progress.
        onboard_state = ONBOARD_STATE_WAIT_TO_STORE_MODE;
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**@brief       System reset.
 *
 * @retval      Void.
 */

static void onboard_reset(void)
{

    NVIC_SystemReset();
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
